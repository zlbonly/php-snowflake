# php-snowflake
## 基于Twitter-Snowflake：自增ID算法

### 1、简介

Twitter 早期用 MySQL 存储数据，随着用户的增长，单一的 MySQL 实例没法承受海量的数据，后来团队就研究如何产生完美的自增ID，以满足两个基本的要求：

* 每秒能生成几十万条 ID 用于标识不同的 记录；

* 这些 ID 应该可以有个大致的顺序，也就是说发布时间相近的两条记录，它们的 ID也应当相近，这样才能方便各种客户端对记录 进行排序。

Twitter-Snowflake算法就是在这样的背景下产生的。

### 2、核心

* Twitter 解决这两个问题的方案非常简单高效：每一个 ID 都是 64 位数字，由时间戳、工作机器节点和序列号组成， ID是由当前所在的机器节点生成的。如图：  
![avatar](https://img2018.cnblogs.com/blog/663847/201910/663847-20191026153737475-954175194.png）

* 下面先说明一下各个区间的作用。
* 符号位：用于区分正负数。1为负数，0为整数。一般不需要负数，所以值固定为0。
* 时间戳：一共预留41bit保存毫秒级时间戳。因为毫秒级时间戳长度是13位：41位二进制最大值(T)是：241−1=2199023255551 , 刚好13位。可以表示的年份 = T / (3600 * 24 * 365 * 1000) = 69.7年。换算成Unix时间也就是可以表示到：2039-09-07 23:47:35：
* 大家会觉得这个时间不够用啊，没关系，后面会讲如何优化。

* 工作机器：预留了10bit保存机器ID。只要机器ID不一样，每毫秒生成的ID是不一样的。一共可以支持多少台机器同时生成ID呢？ 答案是 1023 台（210−1）。
* 如果工作机器比较少，可以使用配置文件来设置这个id，或者使用随机数。如果机器过多就得单独实现一共工作机器ID分配器了，比如使用redis自增，或者利用Mysql auto_increment机制也可以达到效果。
* 序列号：序列号一共是12bit，为了处理在同一机器同一毫秒内需要给多条消息分配id的情况，一共可以产生4095个序列号(0~4095， 212−1)。
* 综上：同一台机器1毫秒内可产生4095个ID，全部机器1毫秒内可产生 4095 * 1023 个ID。由于全是在各个机器本地生成，效率非常高。


### 优化
* 1、时间戳优化
* 如果时间戳取当前毫秒级时间戳，那么只能表示到2039年，远远不够。我们发现，1970到当前时间这个区间其实是永远都不会用了，那么，为何不使用偏移量呢？也就是时间戳部分不直接取当前毫秒级时间戳，而是在此基础上减去一个过去时间：
```
id = (1572057648000 - 1569859200000) << 22; 
输出：
id=9220959240192000
```
* 上面代码中，第一个时间戳是当前毫秒级时间戳，第二个则是一个过去时间戳（1569859200000表示2019-10-01 00:00:00）。这样我们可以表示的年大概是 当前年份(例如2019) + 69 = 2088 年，很长一段时间内都够用。


### 说明 
   测试样例中 开启了多个线程生成id,但是每个对象在自己线程中是独立的，因此会出现 重复现象。 可以使用 时间戳+机器ID+进程ID+序列号 优化
   * 缺点  需要独立部署id生成器，增加维护成本
   

   * 另外 可以考虑 使用 MongoDB ObjectId  实现生成策略类似雪花算法。 时间戳+机器ID+进程ID+序列号=>ObjectId对象 （缺点：使用机器ID和进程ID，64位Long无法存储，只能生成特殊ObjectId对象。）
